IOC DI都是为了解耦
IOC（控制翻转）：一种结果（注：DI不是实现IOC的唯一方式，还有其他方式）
DI（依赖注入）：一种过程

The Inversion of Control (IoC) and Dependency Injection (DI) patterns are all about removing dependencies from your code.
For example, say your application has a text editor component and you want to provide spell checking. Your standard code would look something like this:
		public class TextEditor
		{
		    private SpellChecker checker;
		    public TextEditor()
		    {
		        this.checker = new SpellChecker();
		    }
		}

What we've done here is create a dependency between the TextEditor and the SpellChecker. In an IoC scenario we would instead do something like this:
		public class TextEditor
		{
		    private ISpellChecker checker;
		    public TextEditor(ISpellChecker checker)
		    {
		        this.checker = checker;
		    }
		}

In the first code example we are instantiating SpellChecker (this.checker = new SpellChecker();), which means the TextEditor class directly depends on the SpellChecker class.
In the second code example we are creating an abstraction by having the TextEditor constructor signature as the SpellChecker dependency class (not initializing dependency in class). This allows us to call the dependency then pass it to the TextEditor class like so:

		SpellChecker sc = new SpellChecker; // dependency
		TextEditor textEditor = new TextEditor(sc);
Now, the client creating the TextEditor class has the control over which SpellChecker implementation to use. We're injecting the TextEditor with the dependency.


代码通过把使用到的对象的控制权交给Spring IOC容器（不用关心实例化过程），再依赖构造器、注入器（setter）、接口实现解耦。
Inversion of Control (IOC) and Dependency Injection (DI) are used interchangeably. IOC is achieved through DI. DI is the process of providing the dependencies and IOC is the end result of DI (Note: DI is not the only way to achieve IOC, there are other ways as well).（http://stackoverflow.com/questions/9403155/what-is-dependency-injection-and-inversion-of-control-in-spring-framework）





深度理解依赖注入（Dependence Injection）（http://www.cnblogs.com/xingyukun/archive/2007/10/20/931331.html）
其实不管是面向服务的编程模式，还是基于插件的框架式编程，为了实现松耦合（服务调用者和提供者之间的or框架和插件之间的），都需要在必要的位置实现【面向接口编程】，
在此基础之上，还应该有一种方便的机制实现具体类型之间的运行时绑定，这就是DI所要解决的问题。