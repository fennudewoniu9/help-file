设计模式原则: 
  对扩展开放，对修改关闭；单一职责原则指导我们实现类要职责单一。

策略模式:
  策略模式是对算法的抽象，是一种行为设计模式；需要什么算法，自己去new然后放入cintext的环境类中；所有算法相当于平行的。

责任链模式:
  责任链模式和策略模式类似，但是两点不同，1：各算法通过类似数据结构中的后继实现串行的Handler；2：客户端执行时并不知道
  具体哪个算法执行，需要Handler自己去判断
  被请求的多个接收者通过后继的引用连接成的一条链，具体哪个节点处理，节点自己判断。

  如果新增一种策略，需要在客户端new的地方增加一句new；如果新增一个责任链节点，只需要在责任链中的两个引用之间插入一个节点。

工厂模式:
  工厂模式使用场景：
  1.会有一组类似的对象需要创建
  2.客户端不可预见具体哪一个对象会被创建(责任链中用到)
  3.可以扩展，且扩展时不需要考虑细节和如何被创建
  简单/静态工厂模式用switch，工厂方法模式生成一个对象(猫狗)，抽象工厂模式生成一组对象(公猫母猫)
  PS：https://mp.weixin.qq.com/s/oRwF6DgiT6t69tzmfUM74Q

  工厂方法模式: 客户端不需要在负责对象的创建,明确了各个类的职责,后期维护容易,增强系统的扩展性；但需要额外的编写代码,增加了工作量
   动物工厂、猫工厂、狗工厂 + 动物类、猫、狗，动物类有猫和狗实现动物类
  简单/静态工厂模式: 就一个具体的工厂来创建对象，代码量少;当需求改变了,我就要改代码
    public class AnimalFactory {
       public static Dog createDog() {
           return new Dog();
       }

       public static Cat createCat() {
           return new Cat();
       }


       // 外界想要猫要狗，这里创建就好了
       public static Animal createAnimal(String type) {
           if ("dog".equals(type)) {
               return new Dog();
           } else if ("cat".equals(type)) {
               return new Cat();
           } else {
               return null;
           }
       }
    }

    // 拿到狗
    Animal A = AnimalFactory.createAnimal("dog");
    A.eat();

    // 拿到猫
    Animal C = AnimalFactory.createAnimal("cat");
    C.eat();
  抽象工厂模式: 抽象工厂模式就比较复杂了，我们一般的应用都写不到。工厂方法模式的工厂是创建出一种产品，而抽象工厂是创建出一类产品。（难以扩展产品族）
   动物工厂、公动物工厂（动物是方法返回类型，但new的是公母狗/猫动物类）、母动物工厂（动物是方法返回类型，但new的是公母狗/猫动物类）
   动物类、狗/猫动物抽象类、公母狗/猫动物类
  总结: 总的来说我们用简单工厂模式比较多，工厂方式模式的话代码量会比较大，抽象工厂模式的话需要业务比较大的情况下才会用到

适配器模式:
  通过一个适配器Adapter把一个接口转化为另一个借口，一般使用类适配器，不使用对象适配器（没增加一个被适配的接口就要增加一个适配器）
  类适配器：extends适配的类，实现被适配的类，这样每增加一个被适配的类，直接增加一个implements和对应的方法即可。比如2项电转3、4项电

状态模式:
  需要一个总的类似switch的类聚合管理，每个状态之间指定下一个状态是什么。



策略模式 vs 状态模式 vs 工厂模式: 
  策略模式和状态模式很像，策略每一个是独立的，而状态模式里所有状态聚合在一起管理，且状态之间会跳转，所以和责任链模式也很像，但责任链和状态模式处理完成之后流向不一样。状态
  模式避免了很多if else。简单/静态工厂模式用switch，工厂方法模式生成一个对象(猫狗)，抽象工厂模式生成一组对象(公猫母猫)
  PS: 工厂模式：https://mp.weixin.qq.com/s/oRwF6DgiT6t69tzmfUM74Q

如果新增一种策略，需要在客户端new的地方增加一句new；如果新增一个责任链节点，只需要在责任链中的两个引用之间插入一个节点。



SOLID 原则:  #https://www.jianshu.com/p/1c6498da3862
 SOLID 原则提供了五条指导思想，如果我们遵从它们的话，将可以显著的提升我们软件可维护性。
 SOLID原则是针对面向对象编程和设计的五大依赖关系管理。SOLID首字母缩写词，是由Robert Cecil Martin （也被称为 “Bob叔叔” ）提出的。每个字母代表另外一个三个
字母的首字母缩写， 用来描述一个原则。
1.Single Responsibility Principle -- 单一职责原则（SRP）: 每个类都只有一个目的。这并不意味着每个类应该只有一个方法，而是说类中所有的方法都要与该类的主要功能相关。那些有多个职责的类，应该被分成新的类。
2.Open / Closed Principle -- 开闭原则（OCP）: 软件实体（classes, modules, functions etc.）应该对拓展开放，对修改关闭。一旦模块被开发和测试完成，代码被修改的原因应该只有修复bug这一种情况。 “开放”部分说，您应该能够扩展现有代码（而不是修改之前的代码）以引入新功能。与SRP一样，该原理通过限制对现有代码的更改来降低引入新错误的风险。
3.Liskov Substitution Principle -- 里氏替换原则（LSP）: 面向对象设计的基本原则之一。里氏替换原则中说，任何基类可以出现的地方，子类一定可以出现。有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。
4.Dependency Inversion Principle -- 依赖倒置原则（DIP）: 第一个是高级模块（实现更大的任务）不应该依赖于低级模块（如某个利率公式）。两者都应该依赖于抽象。第二部分规则是抽象不应该依赖于细节。细节应该依赖于抽象。DIP主要涉及到应用中层次化的概念，其中较低级别的模块处理细节的功能，较高级别的模块使用较低级别的类来实现更大的任务。该原则规定了在类之间存在依赖关系的情况下，应使用抽象（如接口）来定义它们，而不是直接引用类。这减少了由较低级别模块的变化导致的错误，导致较高层的错误。DIP经常在依赖注入中被使用。
5.Interface Segregation Principle -- 接口分离原则（ISP）: 客户端不应该强制依赖那些他们没有使用到的接口。这个规则意味着当一个类依赖另一个类时，接口中可以被依赖类显示的成员的数量应该被最小化。通常当您创建一个具有大量方法和属性的类时，该类将被其他类使用，并且只访问其一个或两个成员。随着他们意识到的成员数量的增加，这些类更加紧密地耦合在一起。当您遵循ISP时，大类实现了多个更小的接口，根据用途对功能进行分组。依赖关系与那些相关联用于松耦合，增加健壮性，灵活性以及可复用性。