架构设计第一原则：简单
高并发访问的核心原则其实就一句话“把所有的用户访问请求都尽量往前推”，如果把来访用户比作来犯的"敌人"，我们一定要把他们挡在800里地以外，即不能让他们的请求一下打到我
们的指挥部（指挥部就是数据库及分布式存储）。
################################################################# 序言 #####################################################################
纯粹的讨论架构是剑走偏锋,纯粹的讨论架构是过度化，是在中国开车担心车子跑到200会不会出问题。
互联网三板斧：消息队列，高速缓存，服务拆分，但大部分业务都触及不到架构的天花板。不同的架构是为了更好的解决其自身场景下的各种复杂的团队开发，内外部联调，协同发版交
付的问题。精力应该放在业务需求挖掘及模型的建立。
###########################################################################################################################################

1.可靠性标准SRE:
2.架构演进周期:
3.架构域分类（4A）:
4.架构设计实践--指标:
5.Java中的SPI（Service Provider Interface）和防腐层（Facade）是两个不同的概念，以及SPI、API、Facade的区别？:
6.Apache 的架构师们遵循的 30 条设计原则:
7.微服务拆分原则:
8.微服务拆分思路:
9.BFF&OSFA&网关: 
10.监控指标: 
11.DDD的一些总结:
12.QPS-TPS: 


可靠性标准SRE:
Google在2000年提出的一些衡量系统可靠性的标准：SRE（Site Reliability Engineering，站点可靠性/稳定性工程师）、SLO服务水平/质量对象、SLI服务水平/质量指标、
SLA服务水平/质量协议
# 拓展————华为网络架构图：https://support.huawei.com/enterprise/zh/doc/EDOC1100169483/c3b86e85


架构演进——试错期:
   -- 试错期业务核心问题: 业务不断探索适合的商业模式；
   -- 架构核心关注点: 提升响应速度，快速支持业务上线；
   -- 架构核心原则: 以质量换取速度，可以牺牲一点线上质量(业务可接受范围)来换取更快的响应速度。
   应用发版速度(尤其是IOS)跟不上业务快速迭代的上线周期，动态性是端面临的主要问题，因此端上采用了X的架构：

架构演进——发展期:
   -- 业务核心问题: 隐约看到商业模式，需要加速验证，扩大规模。
   -- 架构关注点: 提升效率(为了有机会去做更多事情,非降低整体成本)，建设更多能力验证业务方向。
   -- 架构演进方向: 前后端的协议、工具的自动化。
      服务端通过Mbaas(服务端提供基础的数据源(商品、用户、搜索、互动)，让客户端/前端通过类SQL的描述一次性获取自己想要的数据，后端不需要增加接口)来实现活动、
      feeds投放的自动化。将更多精力投入到本地化、个性化、数据能力(与算法、推荐、搜索打通)的建设中。
   客户端开发关注两个点: 
      - 对外整体连接协议的梳理，对具体的实现进行服务化封装，以方便后续基础能力的可替换。
      - 组件库的建立，新做一个页面的时候，能通过现有的UI组件进行简单组装，不需要从0开始搭建。组件与服务端打通，组件组装逻辑与数据直接由服务端完成，客户端负责解
      析与渲染。因此这个时期客户端更多的工作是支持交互的基础的UI组件和动态适配性。

架构演进——平台期:
   随着业务的发展，JK基于银行+权益+活动体系的业务达到十几种，逐渐向平台期发展。平台期业务与架构核心问题：
   -- 业务核心问题: 需要让更多的第三方参与到代运营平台的建设中，但是平台生态建设又超出了JK自身的能力。
   -- 架构核心关注点: 扩展性(具备接入业务的能力)、业务隔离(已接入业务平稳运行)、平台基础能力建设(业务更好的发展)。
   -- 架构原则: 做一些更基础的规划，然后把更多的可能性、动态性留给二方或者三方完成。
   核心解决因业务发展带来的代码耦合问题，问题主要体现在整体开发、运维效率低，稳定性差。核心思路是分离系统中不可变和可变的部分；分离出”做什么”与”怎么做”、“谁去做”
   。将业务中不变的部分放入主干，定义出做什么；变化的部分以扩展点形式开放出来，让具体的业务放自己来实现,完成怎么做，谁去做。Swak的扩展点实现支持远程调用，可以让业
   务实现应用级别的隔离，相比传统的分包、分模块隔离方式更加彻底。

架构演进——云端一体化:
   随着无线发展，移动研发逐渐向多端化发展(IOT、小程序)。传统的基于Native＋Web＋服务端的开发方式，逐渐出现瓶颈，我们会发现例如：
   -- 端上同学离业务越来越远，服务端同学没时间做底层领域沉淀。
   -- 各端研发之间存在大量的协同, 整体研发效率低下。
   -- 招人也难了，需要同时招多个技术栈的同学；
   在这种背景下, 我们的关注点回到研发效率上, 从整体研发架构、研发模式出发, 思考什么样的架构演进、关系重塑才能适合当前的业务形态。我们希望探索出适合“ JK这样规模的
   具有独立APP” 的高效研发架构，形成云端一体化的研发能力，支持一云多端的发展。



架构域分类:  熟悉业务，形成业务架构，根据业务架构，作出数据架构和应用架构，最后通过技术架构落地实施
   -- 业务架构（业务架构图）: 将业务需求转化成业务目标，梳理出清洗业务流程和业务元素
      业务架构=业务目标+业务流程+业务要素，业务架构最重要的就是识别出业务流程和业务流程中包含的业务要素，换个角度看就是业务要素与业务要素之间的关系，这些关系组成
      整个业务按照业务场景层、产品功能层、领域模型层、依赖层画出业务架构图
   -- 数据架构（数据架构图）: 描述数据资产及管理资源的架构
      由业务架构驱动，从业务架构分析业务流程、分析领域模型层，从领域模型层触发构建数据架构。数据模型最常用的就是ER图，描述数据实体、属性和关系
   -- 应用架构（应用架构图）: 划分不同功能模块，根据功能模块的关系组合成子系统
      应用架构划分出不同的功能模块，再根据功能模块间的关系，组合成子系统。考虑三点问题：
      怎么划分模块或子系统，模块或子系统都放在架构中的哪一个层次；
      哪些模块或子系统之间是需要交互的；
      将可复用组件或模块进行抽象后下沉，为业务组件提供统一支撑服务。
   -- 技术架构（技术架构图、部署架构图）: 支持业务、数据、应用部署所需的软件与硬件能力
      技术架构涉及到技术问题、技术方案以及技术组建；通过技术方案的形式解决目前业务上碰到的技术问题。可以通过各种技术组建解决，技术组件可以是分布式缓存、消息队列、
      分布式定时任务等，同时包括硬件能力，包括IT基础设施、中间件、网络、通信、处理和标准等。
   总结：一句话总结设计方法论，挖掘需求目标，根据需求分析找到业务流程以及业务元素，给出业务架构，根据业务架构的领域模型给出数据架构，应用架构规划出模块和子系统，确
      认模块和子系统的边界条件，针对技术问题给出技术架构，同时给出部署架构。在做架构的设计的时候，需要考虑架构的可持续的发展以及面向未来的扩展能力。



架构设计实践--指标:  
   高性能:  消息队列、多级缓存、服务拆分          : 三板斧
   高可用:  可降级、可限流、可替换               : 冗余
   扩展性:  规范扩展方式、识别扩展点、注册扩展点   : 三要素



架构设计实践--原则:  
   -- 规范（编码规范、框架规范、单测规范、管理规范）
   -- 架构设计一定要考虑备选方案，并且要是完整的备选方案
   -- 外系统交互设计必须由反腐层（接口层）来处理
   -- 外部接口设计必须是幂等的、可监控的、可降级的、最好是无状态的
   -- 技术方案必须是可落地的，需要对技术方案进行代码层的验证，保证其可行性
   -- 依赖关系只能是上层依赖下层，不要打破依赖关系



Java中的SPI（Service Provider Interface）和防腐层（Facade）是两个不同的概念，以及SPI、API、Facade的区别？:
    SPI: 是一种Java的标准服务提供者框架，是一种机制，用于在运行时发现和加载实现某个接口的服务提供者，它允许开发者定义服务接口，然后由不同的实现方来提供具体的实现。
         这种机制可以让应用程序更加灵活，可以在运行时动态地加载和替换服务实现，而不需要修改代码。SPI通常用于框架和库中，比如JDBC、Servlet、JAX-WS等。
    防腐层（ACL Anticorruption Layer）: 是一种设计模式，它用于将两个不同的系统或模块隔离开来，以避免它们之间的耦合。防腐层通常用于将外部系统的接口封装起来，以
           便应用程序可以更加容易地与外部系统进行交互。用于数据转换和适配核心思想是通过一个中间层来“翻译”外部系统的数据和行为，防腐层可以帮助应用程序更好地适应外
           部系统的变化，同时也可以提高应用程序的可测试性和可维护性。
    因此，SPI和防腐层是两个不同的概念，它们的作用和应用场景也不同。在Java中，SPI通常用于框架和库中，而防腐层则可以用于任何需要与外部系统进行交互的应用程序中。简
    单的说就是API是给开发人员用的，而SPI是给框架使用的。

   API: API，Application Programming Interface，是实现方制定接口并完成对接口的实现，调用方无权选择不同的实现。API是给开发人员使用的。
   SPI: SPI，全称Service Provider Interface，SPI是调用方来制定接口，提供给外部来实现，调用方在调用时选择自己需要的外部实现。SPI是给框架使用的。是Java提供的
        一种服务加载方式。它是一种将服务接口和服务实现分离达到解耦，大大提升了程序的可扩展性的机制。引入服务提供者就是引入了SPI接口的实现者，通过本地的注册发现获
        取具体的实现类，轻松可插拔。
   Facade，门面模式/外观模式: 门面模式为子系统提供一组统一的接口，定义一组高层接口来封装子系统的复杂性让子系统更易用。解决易用性问题（封装系统的底层实现，隐藏系
        统的复杂性，提供一组更加简单易用、更高层的接口），解决性能问题（多次rpc聚合成一次rpc），解决分布式事务问题（多次rpc变成一次也就实现了单次事务问题）。使得
        客户端可以更简单地与子系统交互。
   总结: 门面模式是接口设计的指导思想，旨在为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。典型使用场景是提升接口易用性，解决性能问题，解决分布式事务问
        题。SPI则是一种将服务接口和服务实现分离达到解耦，大大提升了程序的可扩展性的机制。



Apache 的架构师们遵循的 30 条设计原则:
1.时刻要想投入产出比（ROI）。
2.不可能预测到用户将会如何使用我们的产品。所以要拥抱 MVP（Minimal Viable Product），最小可运行版本。
3.等到有人提出再说（除非是影响核心流程，否则就等到需要的时候再去做）。
4.要知道一个 server 是如何运行的，从硬件到操作系统，直到编程语言。优化 IO 调用的数量是你通往最好架构的首选之路。
5.要了解 Amdhal 同步定律。在线程之间共享可变数据会让你的程序变慢。只在必要的时候才去使用并发的数据结构，只在必须使用同步（synchronization）的时候才去使用同步。
   如果要用锁，也要确保尽可能少的时间去 hold 住锁。如果要在加锁后做一些事情，要确保自己在锁内会做哪些事情。
6.保证消息只被传递一次，不管失败，这很难，除非你要在客户端和服务端都做控制。试着让你的系统更轻便。你要知道大部分的承诺 exactly-once-delivery 的系统都是做了精简的。
7.知道 CAP（一致性、分区容错、可用性） 理论。可扩展的事务（分布式事务）是很难的。如果可能的的话，尽可能的使用补偿机制。RDBMS 事务是无法扩展的。
 #PS:https://www.infoq.cn/article/eRL5FcUfm2FzCGes5iwp
Apache 的架构师们遵循的 30 条设计原则--主要涉及以下6个纬度: 
基本原则-极简、
功能选择-MVP版本、
服务端设计和并发-了解IO且少用想成共享数据、
分布式系统-CAP和exactly-once、
用户体验-少配置、
艰难的问题-不要轻易的去换编程语言。。。。

微服务拆分原则:
   2个披萨原则: 两个披萨原则最早是由亚马逊 CEO 贝索斯提出的，他认为如果两个披萨不足以喂饱一个项目团队，那么这个团队可能就显得太大了，所以一个服务的人数划分为 5-7 人
   比较合适。因为人数过多的项目将不利于决策的形成，而让一个小团队在一起做项目、开会讨论，则更有利于达成共识，并能够有效促进企业内部的创新。
   康威定律: 你想要架构成为什么样，就将团队分成怎样的结构。比如前后端分离的团队，架构就是基于前后端分离。在基于微服务设计的团队里，一个很好的理念是自管理，团队内部对
   于自己所负责的模块高度负责，进行端对端的开发以及运维。

微服务拆分思想:
   高内聚低耦合，服务粒度适中；以业务模型切入；演进是拆分；阶段性合并。

BFF&OSFA&网关: https://www.cnblogs.com/sfnz/p/14331869.html

监控指标: 
1.硬件，大促期间所有应用的CPU，内存，网络IO，连接数，磁盘等数据
2.数据库，tps，qps，负载，IO，慢查询，cpu内存
3.中间件，redis，mq，注册中心，配置中心，调度中心，统一网关，鹊桥，EDI
4.应用，tps，平均响应时间，最大响应时间，可用率，失败率，线程池，数据库连接池，虚拟机
5.6.1～6.18期间发版次数、机器扩容情况
6.6.1～6.18期间数据库脚本提交情况（DDL、DML）

DDD的一些总结:
需要领域专家和开发一起设计
1.分析需求确定需要解决的问题和业务期望的目标，确定问题域统一语言
2.战略阶段进行分而治之思想进行拆分确定边界上下文、确定系统的架构
3.战术阶段：领域分析建模、确定设计模型、编码实现领域的建模。在编码的时候发现问题进而去优化、进化领域模型。

不足：缺少过程指导严重依赖团队人员经验、没有匹配的需求管理体系、缺少完整的架构体系
领域设计的精髓是对边界的控制，通过分层等实现。
一般的分层：
# application-独立部署，业务聚合，对应领域过程（领域服务的聚合）
# domain-独立部署，一条业务拆分出多个应用，对应领域服务
# 扩展点-打包进domain，多实现，对应领域能力（可扩展的能力）
# 基础架构-打包进domain，访问数据库、es的外部数据源
# interface-独立部署，门面，对外暴露接口
# spi-打包进domain，一组业务活动、扩展点和固化的业务集，对应领域产品
四大分类：设计领域模型（实体、值对象）的四种分类、架构、模式，既然是领域对象那就包括属性和动作/服务；失血模型、贫血模式、充血模式、胀血模式。
领域模型建模的方法论：用例分析法、四色建模法、事件风暴法（事件属性命令实体），最终产出是领域对象、领域服务、领域事件。


12.QPS-TPS: 
  QPS: 每秒钟处理完请求的次数，注意这里是处理完。具体是指发出请求到服务器处理完成功返回结果。可以理解在server中有个counter，每处理一个请求加1，1秒后counter=QPS。
  TPS: 每秒钟处理完的事务次数，一般TPS是对整个系统来讲的。一个应用系统1s能完成多少事务处理，一个事务在分布式处理中，可能会对应多个请求，对于衡量单个接口服务的处理
  能力，用QPS比较多。
  并发量: 系统能同时处理的请求数
  RT: 响应时间，处理一次请求所需要的平均处理时间
  计算关系: 
    QPS = 并发量 / 平均响应时间
    并发量 = QPS * 平均响应时间
  高性能接口一般TP99在TPS5000的情况下要求100ms返回，数据库要控制在40ms以内，cleverDB上0.1s就是慢查询。（0.1s扫描500行代码）
