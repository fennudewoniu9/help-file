----------------------------------------------------------------------------------------------------
意大利、C语言开发
读: 11w/s
写: 8.12w/s

场景: 缓存、任务队列、应用排行榜、网站访问统计、数据过期处理、分布式集群架构中的session分离
#http://www.cnblogs.com/qunshu/p/3196972.html
￼
事务: 串行化事务
持久化: 内存中的数据转移到硬盘上，两种持久化的区别（RDB、AOF）
数据类型（指的是value的值）: 字符串、哈希（类似map）、列表、集合、有序集合；分别用于处理的场景：
  字符串：一个键值对；可以针对key增删查
  哈希：一个对象拥有多个属性；可以单独获取所有属性的key值和所有属性的value值，可以针对key值加减对应的value，可以添加删除key值，可以hlen获取属性的数量
  列表：类似一个队列模型；可以左右两头操作，可以push时key存在再进行add元素，可以pop-同时进行获取和remove操作，可以根据index获取、覆盖值，可以在index前后add值，可以范围获取，可以len获取元素的数量
  集合：类似数学模型里的两个唯一元素的集合；元素唯一，可以获取两个集合的合集、交集、一个集合不在另一个集合里的元素并存储到新的集合（分别对应两个圆的合、交、非），可以获取元素数量，可以随机获取n个元素，可以移动某个元素到另一个集合
  有序集合：集合元素添加时附带一个分值；可以获取元素数量，可以获取分值区间内的数量，可以添加一个带分值的元素（分值一样ascci大的index大），可以删除一个元素（集合不存在不报错），可以获取元素的index值、分值、排名（分值、index(0开始)由小到大，排名由大到小）


Q&A: 除了超时还有什么一致性维护策略？
A: 设置超时；更安全的是先更新DB再更新redis，遇到redis失效、且读发生在update db之前、且读的时间长于写的时间这样的几率很小，
   如果想避免这种小概率事件，可以使用分布式事务解决。



Redis 命令: 
  #在线命令测试: http://try.redis.io/
  启动: 
    后台启动：./src/redis-server ./redis.conf  #redis.conf中的daemonize yes
    前台启动：./src/redis-server
  
  进入客户端:
    ./src/redis-cli
  
  查看reids信息:
    info
  
  查看reids的client信息:
    client list
----------------------------------------------------------------------------------------------------

1: 什么是redis:
	- Redis 是一个基于内存的高性能key-value数据库，支持保存多种数据结构，定期通过异步操作把数据库数据flush到硬盘上进行保存。
  - 单个value的最大限制是1GB，不像memcached只能保存1MB的数据，也可以对存入的Key-Value设置expire时间

2: Redis是单进程单线程的:
  redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销

3: 分布式:
  - Master会将数据同步到slave，而slave不会将数据同步到master。Slave启动时会连接master来同步数据。这是一个典型的分布式读写分离模型。我
    们可以利用master来插入数据，slave提供检索服务。这样可以有效减少单个机器的并发访问数量
  - 为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备
  PS: 读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个
      节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。

4: 淘汰策略:
  MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据
  相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 6种数据淘汰策略：
    - voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
    - volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
    - volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
    - allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
    - allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
    - no-enviction（驱逐）：禁止驱逐数据

5: Memcache与Redis的区别都有哪些:
  - 存储(持久化)方式
    Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。
    Redis有部份存在硬盘上，这样能保证数据的持久性。
    AOF／数据库快照两种，参考8

  - 数据支持类型
    Memcache对数据类型支持相对简单。
    Redis有复杂的数据类型。

  - 使用底层模型不同
    它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。
    Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

  - value大小
    redis最大可以达到1GB，而memcache只有1MB

6: Redis 常见的性能问题都有哪些？如何解决:
  - Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好
    不要写内存快照。
  - Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速
    度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份
    数据，策略为每秒同步一次。
  - Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。
  - Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内
　　　
7: redis 最适合的场景:
  - 根据与Memecache的区别确定
  - 会话缓存（Session Cache）：购物车信息，优势在于支持持久化
  - 全页缓存（FPC）：提高网页加载速度
  - 队列：因为提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。就类似于本地程序语言（如Python）对 list 的 push/pop 操作。
    如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求
    。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看
  - 排行榜/计数器：集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，只需执行一下命令即可：
    ZRANGE user_scores 0 10 WITHSCORES

8: Redis 分别提供了 RDB 和 AOF 两种持久化机制:
  - RDB 将数据库的快照（snapshot）以二进制的方式保存到磁盘中
  - AOF 则以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到AOF文件（使用网络通讯协议的格式来保存），以此达到记录数据库状态的目的。

    * AOF:
      1.模式:
        - 不保存（AOF_FSYNC_NO）
          # 每次调用 flushAppendOnlyFile 函数， WRITE 都会被执行， 但 SAVE 会被略过
        - 每一秒钟保存一次 （AOF_FSYNC_EVERYSEC）
          # 写入操作由主进程执行，阻塞主进程。保存操作由后台子进程调用的，不直接阻塞主进程，但保存操作完成的快慢会影响写入操作的阻塞时长。
            # - 子进程进行 AOF 重写期间，主进程可以继续处理命令请求。
            # - 子进程带有主进程的数据副本，使用子进程而不是线程，可以在避免锁的情况下，保证数据的安全性。
          # 具体可能不是每秒一次，还要看flushAppendOnlyFile 函数时 Redis 所处的状态有关（子线程是否正在执行 SAVE）
        - 每执行一个命令保存一次（AOF_FSYNC_ALWAYS）
          # 每次执行完一个命令之后， WRITE 和 SAVE 都会被执行

      2.同步命令到 AOF 文件的整个过程可以分为三个阶段:
        命令传播：Redis 将执行成功的命令、命令的参数、命令的参数个数等信息发送到 AOF 程序中。
        缓存追加：AOF 程序根据接收到的命令数据，将命令转换为网络通讯协议的格式，然后将协议内容追加到服务器的 AOF 缓存中。
        文件写入和保存：AOF 缓存中的内容被写入到 AOF 文件末尾，如果设定的 AOF 保存条件被满足的话， fsync 函数或者 fdatasync 函数会被调用，将写入的
        内容真正地保存到磁盘中。

      3.性能:
            模式            WRITE 是否阻塞？   SAVE 是否阻塞？     性能                    停机时丢失的数据量
        AOF_FSYNC_NO            阻塞              阻塞           高        操作系统最后一次对 AOF 文件触发 SAVE 操作之后的数据。
        AOF_FSYNC_EVERYSEC      阻塞              不阻塞         中                  一般情况下不超过 2 秒钟的数据。
        AOF_FSYNC_ALWAYS        阻塞              阻塞           低                    最多只丢失一个命令的数据。

      4.AOF 文件的读取和数据还原:
        a.创建一个不带网络连接的伪客户端（fake client）。
        b.读取 AOF 所保存的文本，并根据内容还原出命令、命令的参数以及命令的个数。
        c.根据命令、命令的参数和命令的个数，使用伪客户端执行该命令。
        d.执行 2 和 3 ，直到 AOF 文件中的所有命令执行完毕。
        # 因为 Redis 的命令只能在客户端的上下文中被执行，而 AOF 还原时所使用的命令来自于 AOF 文件，而不是网络，所以程序使用了一个没有网络连接的
        # 伪客户端来执行命令。伪客户端执行命令的效果，和带网络连接的客户端执行命令的效果，完全一样。

        # 为了避免对数据的完整性产生影响， 在服务器载入数据的过程中， 只有和数据库无关的订阅与发布功能可以正常使用， 其他命令一律返回错误。

      5.AOF 重写:
        被频繁操作的键，对它们所调用的命令可能有成百上千、甚至上万条，重写只是保留对某一个key的最终值，而不保留过程命令，类似多个命令的合并。

      # 由于性能问题，最好不要在master节点上做，而是在某一个slave上开启
      # http://redisbook.readthedocs.io/en/latest/internal/aof.html

8: 命令:
  expire: 如果对key使用set或del命令，那么也会移除expire time，尤其是set命令。 # https://blog.csdn.net/westsource/article/details/6640526
  Incr: 将key中储存的数字值增一，如果key不存在，那么key的值会先被初始化为0，然后再执行INCR操作，且将key的有效时间设置为长期有效。
  setnx: 将key的值设为value，当且仅当key不存在。若给定的key已经存在，则SETNX不做任何动作。设置成功，返回1。设置失败，返回0。可用来实现分布式锁。如下：
          method(value -> 
            long result = redisClient.setnx(key, value);
            if(result == 1){
                redisClient.expire(key, seconds);
            } else if(redisClient.ttl(key)<0){
                redisClient.expire(key, secondes);
            }
            return result == 1;
          )
  
















